<!DOCTYPE html>
<html lang="en">
    <head>

        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title> notesGPT</title>

        <!-- <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@2/css/pico.min.css"> -->
         <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">

        <!-- (Optional) Also load Rounded + Sharp styles -->
        <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Sharp" rel="stylesheet">
        <link rel="stylesheet" href="style.css">

    </head>

    <body style="display: flex; flex-direction: column; align-items: center;">

        <br>

        <div style="width: 30%;">
            <div class="grid">
                <input type="range" id="size">
                <input type="color" id="color">
                <input type="checkbox" id="showBBox">

            </div>
        </div>

        <div id="canvas-wrapper" style="position: relative; display: inline-block;">
            <canvas id="canvas" width="2500" height="1150" style="background-color: white; border: 1px solid black;"></canvas>
            <canvas id="overlay" width="2500" height="1150" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>

            <!-- buttons -->
            <div class="tool-bar" style="position: absolute; top: 88%; left: 50%; transform: translateX(-50%);">
                <!-- tools -->
                <button class="tool" id="pen"> <span class="material-symbols-outlined">ink_pen</span></button>
                <button class="tool" id="eraser"> <span class="material-symbols-outlined">ink_eraser</span></button>
                <button class="tool" id="select"> <span class="material-symbols-outlined">select</span></button>

                <div style="color:darkgrey"> | </div>
                <!-- undo/redo -->
                <button id="undo"> <span class="material-symbols-outlined">undo</span></button>
                <button id="redo"> <span class="material-symbols-outlined">redo</span></button>

                <div style="color:darkgrey"> | </div>
                <!-- add elements -->
                <button id="add"> <span class="material-symbols-outlined">add</span></button>

            </div>

            

        </div>

        <button class="bullet-button"><span class="material-symbols-outlined">arrow_drop_down</span></button>
    </body>

    <script type="module">

        

        //Get canvas and overlay
        const canvas_wrapper = document.getElementById("canvas-wrapper")

        const canvas = document.getElementById("canvas")
        const ctx = canvas.getContext("2d")

        canvas.width = window.innerWidth
        canvas.height = window.innerHeight

        const overlay_canvas = document.getElementById("overlay")
        const overlay = overlay_canvas.getContext("2d")

        //Get buttons and options
        const pen_btn = document.getElementById("pen")
        const eraser_btn = document.getElementById("eraser")
        const select_btn = document.getElementById("select")
        const context_btn = document.getElementById("context") //temporary

        const undo_btn = document.getElementById("undo")
        const redo_btn = document.getElementById("redo")

        const add_btn = document.getElementById("add")

        //options
        const size_slider = document.getElementById("size")
        const color_selector = document.getElementById("color")
        const showBBox_check = document.getElementById("showBBox")

        let shown = true



        // #region helper functions

        function normalizeRect({left, top, width, height}) {
            const x1 = Math.min(left, left + width);
            const y1 = Math.min(top,  top  + height);
            const x2 = Math.max(left, left + width);
            const y2 = Math.max(top,  top  + height);
            return { left: x1, top: y1, width: x2 - x1, height: y2 - y1 };
        }


        function pointInRect(x, y, rect) {
            const r = normalizeRect(rect);
            return x >= r.left && x <= r.left + r.width &&
                    y >= r.top  && y <= r.top  + r.height;
            }

            function rectsIntersect(a, b) {
            const r1 = normalizeRect(a), r2 = normalizeRect(b);
            return !(r2.left > r1.left + r1.width  ||
                    r2.left + r2.width < r1.left  ||
                    r2.top  > r1.top  + r1.height ||
                    r2.top  + r2.height < r1.top);
            }

            function rectContains(rect, x, y, size=0) {
                return (
                    x - size/2 >= rect.left &&
                    x + size/2<= rect.left + rect.width &&
                    y - size/2 >= rect.top &&
                    y + size/2<= rect.top + rect.height
                );
            }

        
            //#endregion

        // #region drawing mode classes

        class Mode {
            constructor(context=ctx) {this.ctx = context;}

            mouseDown(e) {return}
            mouseMove(e) {return}
            mouseUp(e) {return}
        }

        //#region PEN

        function pointsToPath2D(points){
            const path = new Path2D();
            if (!points) return path

            path.moveTo(points.x[0], points.y[0]);
            for (let i = 1; i<points.x.length; i++) {
                path.lineTo(points.x[i], points.y[i]);
            }
            return path
        }

        class Stroke{
            constructor(c, s, bpID=null) {
                this.color = c;
                this.size = Number(s) || 4;
                this.cap = "round";
                this.join = "round";
                this.dash = [],

                this.points = {x: [], y: []}
                this.initialPoints = null
                this.path = new Path2D()

                this.bbox = {min_x: null, max_x: null, min_y: null, max_y: null, left: null, top: null, width: null, height: null}

                this.bpID = bpID
                this.startingBP = null

            }

            getPath(){

                this.path = new Path2D()

                if (!this.points) return this.path
                this.path.moveTo(this.points.x[0], this.points.y[0]);

                for (let i = 1; i<this.points.x.length; i++) {
                    this.path.lineTo(this.points.x[i], this.points.y[i]);
                }

                return this.path
            }

            addPoint(x,y) {
                this.points.x.push(x)
                this.points.y.push(y)
            }

            translateStroke(dx, dy) {

                for (let i = 0; i < this.points.x.length; i++) {
                        this.points.x[i] = this.initialPoints.x[i] + dx;
                        this.points.y[i] = this.initialPoints.y[i] + dy;
                    }

                if (this.bbox.min_x !== null) {
                        this.bbox.min_x += dx;
                        this.bbox.max_x += dx;
                        this.bbox.min_y += dy;
                        this.bbox.max_y += dy;

                        this.bbox.left  += dx;
                        this.bbox.top   += dy;
                    }
             }

        }


        function DrawStroke(s, showBounding=false){
            ctx.lineWidth = s.size
            ctx.lineCap = s.cap
            ctx.lineJoin = s.join
            ctx.strokeStyle = s.color
            ctx.stroke(s.getPath())
            if (showBounding){
                drawBBox(s.bbox)
            }
        }

        function RenderStrokes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            let bpInfoDict = {}

            for (const bp of bulletPoints){
                bpInfoDict[bp.id] = {opened: bp.opened, changeY: bp.bbox.top - bp.startingY}
            }


            for (const s of strokes){
                if (bpInfoDict[s.bpID].opened){
                    // console.log(s.initialPoints.y[0])
                    s.translateStroke(0, bpInfoDict[s.bpID].changeY)
                    DrawStroke(s)
                }

                else if (s.bpID === null || s.bpID === undefined){
                    DrawStroke(s)
                }
            }

            for (const bp of bulletPoints){
                drawBBox(bp.bbox)
            }
        }

        function updateBBox(bbox, x, y) {
            if (bbox.min_x === null) {
                bbox.min_x = bbox.max_x = x
                bbox.min_y = bbox.max_y = y
            }
            else {
                if (x < bbox.min_x) bbox.min_x = x;
                if (x > bbox.max_x) bbox.max_x = x;
                if (y < bbox.min_y) bbox.min_y = y;
                if (y > bbox.max_y) bbox.max_y = y;
            }

            bbox.left = bbox.min_x
            bbox.top = bbox.min_y
            bbox.width = bbox.max_x - bbox.left
            bbox.height = bbox.max_y - bbox.top
        }

        function drawBBox(bbox) {
            overlay.fillStyle = "rgba(0, 100, 255, 0.4)"
            overlay.fillRect(bbox.left, bbox.top, bbox.width, bbox.height)

            overlay.strokeStyle = "rgba(0, 100, 255, 1)"
            overlay.strokeRect(bbox.left, bbox.top, bbox.width, bbox.height)
        }

        let drawing = false

        class PenMode extends Mode {
            constructor(context=ctx) {super(context)}

            mouseDown(e) {
                drawing = true
                const {x, y} = getXY(e)
                
                currentStroke = new Stroke(color, size)

                for (const bp of bulletPoints){
                    if (rectContains(bp.bbox, x, y, currentStroke.size)){
                        currentStroke.startingBP = bp
                        currentStroke.bpID = bp.id

                        break
                    }
                }

                if (currentStroke.startingBP){
                    if (rectContains(currentStroke.startingBP.bbox, x, y, currentStroke.size)){
                        currentStroke.addPoint(x, y)
                    }
                }
                else {
                    currentStroke.addPoint(x, y)
                }

                updateBBox(currentStroke.bbox, x, y)
            }

            mouseMove(e) {
                if (!drawing) return
                const {x, y} = getXY(e)
                if (currentStroke.startingBP){
                    if (rectContains(currentStroke.startingBP.bbox, x, y, currentStroke.size) ){
                        currentStroke.addPoint(x, y)
                        updateBBox(currentStroke.bbox, x, y)
                        DrawStroke(currentStroke, showBBox)
                    }
                }
                else {
                    currentStroke.addPoint(x, y)
                    updateBBox(currentStroke.bbox, x, y)
                    DrawStroke(currentStroke, showBBox)
            }}

            mouseUp(e) {
                drawing = false
                strokes.push(currentStroke)
                DrawStroke(currentStroke, showBBox)

                currentStroke.initialPoints = {
                    x: [...currentStroke.points.x],
                    y: [...currentStroke.points.y]
                }

                currentStroke = null
                
            }
        }
        //#endregion

        //#region ERASER
        class EraserMode extends Mode {
            constructor(context=ctx) {super(context)}

            mouseDown(e) {
                drawing = true;
                console.log("ERASER")
            }

            mouseMove(e) {
                const {x,y} = getXY(e);
                if (drawing){
                    for (const [i, s] of strokes.entries()){
                        if (ctx.isPointInStroke(s.path, x, y)){
                            strokes.splice(i, 1)
                            RenderStrokes()
                        }
                    }
                }
            }

            mouseUp(e){
                drawing = false
            }
        }
        //#endregion

        //#region SELECTOR

        function newSelection(){
            return {
                bbox: {start_x: null, start_y: null, left: null, top: null, width: null, height: null}  
            }
        }

        function updateSelection(selection, x, y, includeStart=true){
            if (!selection.bbox.start_x){
                if (includeStart){
                    selection.bbox.start_x = x
                    selection.bbox.start_y = y
                }
                else {
                    selection.bbox.start_x = null
                    selection.bbox.start_y = null
                }
            }

            else {
                if (x < selection.bbox.start_x) {selection.bbox.left = x}
                else {selection.bbox.left = selection.bbox.start_x}
                selection.bbox.width = Math.abs(x - selection.bbox.start_x)

                if (y < selection.bbox.start_y){ selection.bbox.top = y}
                else {selection.bbox.top = selection.bbox.start_y}
                selection.bbox.height = Math.abs(y - selection.bbox.start_y)
            }}

        let currentSelection = null

        let selecting = false

        class SelectMode extends Mode {
            constructor(context=ctx) {super(context)}

            mouseDown(e) {
                const {x,y} = getXY(e)
                if (currentSelection && pointInRect(x, y, currentSelection?.bbox)){
                     selecting = false
                     let test = document.createElement("button")
                     test.style.position = "absolute"
                     test.style.left = `${x}px`
                     test.style.top = `${y}px`
                     test.id = "test"

                     canvas_wrapper.append(test)

                     return
                }

                selecting = true
                currentSelection = newSelection()
                updateSelection(currentSelection, x, y)
            }

            mouseMove(e) {
                if (!selecting) return
                const {x,y} = getXY(e)
                updateSelection(currentSelection, x, y)
                drawBBox(currentSelection.bbox)
            }

            mouseUp(e){
                selecting = false
            }
        }

        //#endregion
    
        //#region ADD 

        let bulletPoints = []

        class BulletPoint {
            static id = 0
            constructor(x,y, pointEnv=bulletPoints, titleHeight=70){

                this.bbox = {left: x, top: y, width:500, height:100}
                this.startingY = this.bbox.top
                this.existingX = null

                this.btn = document.createElement("button")
                this.id = BulletPoint.id++
                this.btn.id = `btn-${this.id}`

                this.btn.style.position = "absolute";
                this.btn.style.left = `${this.bbox.left}px`
                this.btn.style.top = `${this.bbox.top}px`
                this.btn.className = "bullet-button"
                this.pointEnv = pointEnv 

                this.btn.onclick = () => this.toggle()

                canvas_wrapper.append(this.btn);
                
                this.icon = document.createElement("span")
                this.icon.className = "material-symbols-outlined"
                this.icon.textContent = "arrow_drop_down"

                this.btn.append(this.icon)


                this.opened = true

                this.titleHeight = titleHeight

            }


            getRelativeY(){

                let y = this.pointEnv[0].bbox.top
                for (const bp of this.pointEnv){
                    if (bp === this) break;
                    y = y+bp.titleHeight
                        if (bp.opened){
                            y+= (bp.bbox.height-bp.titleHeight)
                        }
                }
                return y
            }

            updateYPos() {
                const relY = this.getRelativeY()
                this.bbox.top = relY;
                this.btn.style.top = `${relY}px`
            }

            updateXpos(x) {
                this.bbox.left = x
                this.btn.style.left = `${this.bbox.left}px`
            }

            toggle(){
                if (this.opened) {
                    this.originalHeight = this.bbox.height 
                    this.bbox.height = this.titleHeight
                    
                    this.opened = false
                    this.icon.textContent = "arrow_right"
                }
                else {
                    this.bbox.height = this.originalHeight
                    this.opened = true
                    this.icon.textContent = "arrow_drop_down"
                }
                for (const bp of this.pointEnv){
                    bp.updateYPos(bp)
                }

                RenderStrokes()
                showBPregion(bulletPoints)
            }

            setBBox(l, t, w, h) {
                this.bbox = {left:l, top:t, width:w, height:h}
                this.updateYPos()
            }
        }

        function showBPregion(list){
        overlay.clearRect(0, 0, canvas.width, canvas.height)
        for (const bp of list){
            overlay.strokeStyle = "rgba(100, 0, 100, 1)"
            overlay.fillStyle = "rgba(100, 0, 100, .3)"
            overlay.fillRect(bp.bbox.left, bp.bbox.top, bp.bbox.width, bp.bbox.height)
            overlay.strokeRect(bp.bbox.left, bp.bbox.top, bp.bbox.width, bp.bbox.height)
        }
        }
        let currentBulletPoint = null

        class AddMode extends Mode {
            constructor(context=ctx) {
                super(context)
                currentBulletPoint = null
            }

            mouseDown(e) {
                let {x,y} = getXY(e)

                if (currentBulletPoint) {
                    bulletPoints.push(currentBulletPoint)
                    currentBulletPoint = null
                }
                else{
                    if (bulletPoints.length > 0){
                       x = bulletPoints[bulletPoints.length-1].bbox.left
                       y = bulletPoints[bulletPoints.length-1].bbox.top + bulletPoints[bulletPoints.length-1].bbox.height
                       
                    }

                    currentBulletPoint = new BulletPoint(x, y)
                    updateSelection(currentBulletPoint, x, y)
                }
            }

            mouseMove(e) {
                const {x,y} = getXY(e)

                if (currentBulletPoint){
                updateSelection(currentBulletPoint, x, y)
                overlay.clearRect(0, 0, canvas.width, canvas.height)
                overlay.fillStyle = "rgba(100, 0, 100, .4)"
                overlay.fillRect(currentBulletPoint.bbox.left, currentBulletPoint.bbox.top, currentBulletPoint.bbox.width, currentBulletPoint.bbox.height)
                }
            }

            mouseUp(e){
                const {x,y} = getXY(e)

                showBPregion(bulletPoints)

            }
            
            }



        //Defauly values (mode, etc)
        let currentMode = new PenMode()

        pen_btn.onclick = () => {currentMode = new PenMode()}
        eraser_btn.onclick = () => {currentMode = new EraserMode()}
        select_btn.onclick = () => {currentMode = new SelectMode()}
        add_btn.onclick = () => {currentMode = new AddMode()}

        const tool_buttons = document.querySelectorAll(".tool")

        tool_buttons.forEach(tool => {
                tool.addEventListener("click", () => {
                    tool_buttons.forEach(btn => { btn.classList.remove("selected")})
                    tool.classList.add("selected");
                });
        });

        // context_btn.onclick = () => {mode = "context"}


        let size = size_slider.value
        size_slider.addEventListener("input", () => {
            size = size_slider.value;
        })

        let color = color_selector.value
        color_selector.addEventListener("input", () => {
            color = color_selector.value
        })

        let showBBox = false
        showBBox_check.addEventListener("input", () => {
            showBBox = showBBox_check.checked
        })

        let start_x = 0; //for selecting
        let start_y = 0;

        let currentStroke = null
        let strokes = []



        //#region drawing functions

        function getXY(e) {
            const rect = canvas.getBoundingClientRect();
            return {x: e.clientX - rect.left, y: e.clientY - rect.top}
        }

        //#endregion

       function inDrawingArea(e) {
            return e.target === canvas || e.target === overlay_canvas;
        }

        
        document.addEventListener("mousedown", (e) => {
            if (!inDrawingArea(e)) return
            currentMode.mouseDown(e)
        })

        document.addEventListener("mousemove", (e) => {
            if (!inDrawingArea(e)) return
            currentMode.mouseMove(e)
        })

        document.addEventListener("mouseup", (e) => {
            if (!inDrawingArea(e)) return
            currentMode.mouseUp(e)
        })
        </script>
